# AI Business Insights 2026 — Session 3 Lecture Notes (GitHub `.md`)

> **Session theme:** *How AI transforms planning & development through faster delivery (“Hypervelocity Engineering”) and governance embedded into the build process (“Governance by Design”).* 

---

## Table of Contents

* [1. Opening](#1-opening)
* [2. Lecture 1 — Hypervelocity Engineering](#2-lecture-1--hypervelocity-engineering)

  * [2.1 The big idea](#21-the-big-idea)
  * [2.2 “Design → Coding” pipeline](#22-design--coding-pipeline)
  * [2.3 Deployment units, CI/CD, and “stitching”](#23-deployment-units-cicd-and-stitching)
  * [2.4 Why software engineers are still essential](#24-why-software-engineers-are-still-essential)
  * [2.5 Prompt development as engineering](#25-prompt-development-as-engineering)
* [3. Skill Session — Vibe Coding in practice](#3-skill-session--vibe-coding-in-practice)

  * [3.1 What “vibe coding” means](#31-what-vibe-coding-means)
  * [3.2 What it enables (and what it doesn’t)](#32-what-it-enables-and-what-it-doesnt)
  * [3.3 Two modes: Personal hack vs Professional dev](#33-two-modes-personal-hack-vs-professional-dev)
  * [3.4 Common usage patterns](#34-common-usage-patterns)
  * [3.5 Learning path: the “7 steps” ladder](#35-learning-path-the-7-steps-ladder)
* [4. Lecture 2 — Governance Transformation (Governance by Design)](#4-lecture-2--governance-transformation-governance-by-design)

  * [4.1 Session objective](#41-session-objective)
  * [4.2 Why old governance fails in AI-speed development](#42-why-old-governance-fails-in-ai-speed-development)
  * [4.3 Governance vs Control](#43-governance-vs-control)
  * [4.4 The target state: embed governance “by design”](#44-the-target-state-embed-governance-by-design)
  * [4.5 Governance DX/AX and “new-type” talent](#45-governance-dxax-and-new-type-talent)
  * [4.6 Example: governance tooling in DevOps](#46-example-governance-tooling-in-devops)
* [5. Panel Discussion](#5-panel-discussion)
* [6. Q&A](#6-qa)
* [7. Closing + What’s next](#7-closing--whats-next)

---

## 1. Opening

**Agenda overview (Session 3):**

1. Opening
2. Lecture 1: *Hypervelocity Engineering — “Bring Vibe Coding into Business”*
3. Lecture 2: *Governance Transformation for high-speed development in the AI era*
4. Panel discussion
5. Q&A
6. Closing 

**Speakers / roles (as introduced):** the session includes a PwC presenter plus guests (Microsoft Innovation Hub, PwC governance leader, and a skill-session instructor focused on vibe coding). 

---

## 2. Lecture 1 — Hypervelocity Engineering

### 2.1 The big idea

**Hypervelocity Engineering = Business Engineering × Software Engineering**
The lecture frames modern delivery as an integrated loop where:

* Business side shapes *As-Is → To-Be*, product management, and use cases.
* Engineering side turns those into design, code, deploy, and operations.
* **Vibe coding + GitHub Copilot** accelerate the “build” side, but the *system* is more than code: it includes operations, SRE, QA, documentation, and continuous feedback. 

**Key concept:** *“Connect Business ↔ Dev” and “Connect Dev ↔ Ops”*
The diagram explicitly highlights bridging these gaps, with shared data/resources and feedback loops supporting the entire lifecycle. 

---

### 2.2 “Design → Coding” pipeline

The lecture emphasizes that “faster coding” only works if upstream artifacts are structured so AI + teams can reliably execute:

**Business artifacts (examples)**

* As-Is / To-Be analysis documents
* Future scenarios and use case catalog
* Functional + non-functional requirements (NFRs)
* Product-management structure and prioritization 

**Engineering artifacts (examples)**

* Architecture design (including microservice-style decomposition)
* Domain analysis and documentation
* Screen definitions + navigation flows
* Data models + sample data
* Service catalog and explicit IDs/structure to increase precision
* Issues split when tasks are too large (important for AI-assisted work) 

**Why this matters:**
AI-assisted development *amplifies whatever structure you provide*. If your “design inputs” are vague, you’ll get fast output that’s hard to integrate, test, or govern. If you provide structured artifacts, you can industrialize “Design → Issues → Code”.

---

### 2.3 Deployment units, CI/CD, and “stitching”

A practical model is shown as “**stitching + deployment unit**”:

* Code outputs may span multiple stacks (C#, Java, Python, React/HTML/JS, DDL).
* Those are connected to cloud components (example shown using Microsoft Azure elements).
* **CI/CD** is treated as the glue that allows rapid safe iteration, not a “later step.” 

**Interpretation:**
Hypervelocity is not “one big AI-generated app.” It’s a pipeline of smaller deployable units that can be tested, governed, and rolled out incrementally.

---

### 2.4 Why software engineers are still essential

The material is explicit: **a software engineer is required**—responsible for:

* Review
* Judgment calls about work and quality 

**Practical takeaway:**
Vibe coding increases throughput, but it *doesn’t remove accountability*. It shifts effort toward:

* architectural decisions,
* verification,
* integration,
* and quality/safety gates.

---

### 2.5 Prompt development as engineering

The lecture treats prompts as something you **develop**, not something you “find once”:

* Good prompts/configs are widely shared publicly (examples include community prompt/config repositories). 
* But the deck warns: it’s not “use as-is.” 
* Instead, prompts should be **engineered**:

  * Start with a draft prompt + template
  * Inject org-specific know-how
  * Detect gaps vs expectations
  * Iterate until outputs become “reliable deliverables”
  * Then scale into many repeatable jobs 

A key mindset shift described in the slides:

> Prompting is not just writing commands; it is **handing AI the work’s assumptions, viewpoints, and decision criteria** so it can act like a collaborator. 

---

## 3. Skill Session — Vibe Coding in practice

### 3.1 What “vibe coding” means

Definition presented in the skill deck:

* You can make things work by **describing what you want in words**
* Programming knowledge is **not required**
* You can communicate in Japanese (“make something like this”), and get something working in minutes 

---

### 3.2 What it enables (and what it doesn’t)

**Can do (examples from the slide):**

* Personal/small tools (e.g., document checking)
* Small team apps/macros
* Prototypes and MVPs
* Visual explanations and diagrams 

**Not suited for (examples from the slide):**

* Large-scale systems/services
* Tools requiring full org rollout/operational maturity
* High-stakes production services for many users
* Outputs where mistakes are unacceptable 

**Guiding advice:** start small and expand what you can do over time. 

---

### 3.3 Two modes: Personal hack vs Professional dev

The deck separates vibe coding into two patterns:

1. **Personal Hack (Light):** “Make the tool you want right now.”
2. **Professional Dev (Pro):** “Ultra-high-speed development” with stronger expectations.

It contrasts two mottos:

* “Don’t think, just vibe.” (fast creation)
* “Trust, but verify.” (AI is powerful, but you must validate) 

This aligns directly with Lecture 1’s point: speed must be paired with verification and engineering accountability.

---

### 3.4 Common usage patterns

A survey slide lists many practical categories (illustrative examples):

* Writing/report generation
* Aggregation/analysis/visualization
* Data processing/transformation
* Business documents/templates
* Task/project management
* Communication support
* Calculations/simulation
* Bots/chat tools
* File operations/automation
* Forms/input tools
* Landing pages/web pages
* Scraping & info collection
* API integration/workflows
* Learning/knowledge management
* Personal utilities, team tools, even entertainment 

**Why this matters:** the value isn’t only “apps.” It’s **turning micro-pain into micro-tools**, repeatedly.

---

### 3.5 Learning path: the “7 steps” ladder

The deck introduces “**7 steps**” and recommends starting from easy tasks and expanding. 

Concrete levels shown in the material:

* **Level 1: Create a one-page artifact** (e.g., HTML + JS, SVG) 
* **Level 2: Office-tool automation** (e.g., Excel macros) 

  * The deck includes real usage stats showing that AI can expand who can automate (AI-assisted macro creation appears even among people who previously couldn’t write macros). 
* **Level 3: Web services** with explicit warning: **be careful with security and input data** 

---

## 4. Lecture 2 — Governance Transformation (Governance by Design)

### 4.1 Session objective

The governance lecture sets a clear learning goal:

* Understand governance essentials for AI-era development
* Extract implications for **your organization** and **your own career transformation** 

---

### 4.2 Why old governance fails in AI-speed development

A central diagram shows development phases:

* Research/strategy → planning/design → PoC/dev/test → release/operate → improve/scale

The key claim:

* Traditional governance/control was often **after-the-fact** and human/manual.
* In high-speed AI-era development, you must build governance early to reduce impact later (“Governance by Design”). 

**“Walls that block transformation” (common reality):**
Applying traditional controls unchanged often:

* doesn’t prevent/detect risk rationally,
* creates extra work,
* leaves major residual risk. 
  The slide illustrates typical friction points like manual testing burdens, sensitive data handling constraints, Dev/Ops separation, re-validation, and periodic access reviews. 

---

### 4.3 Governance vs Control

The lecture distinguishes:

* **Governance:** a mechanism to *direct, monitor, evaluate, and oversee* so stakeholder expectations are met; it includes both “defense” and “offense” (value creation). 
* **Control:** mechanisms within management processes to prevent/detect risks. 

This is important because “governance” is not only compliance—it’s also **protecting and improving the value of assets and outcomes**. 

---

### 4.4 The target state: embed governance “by design”

Target model:

* AI + reference data/assets support insights and drafting
* Pipelines automate high-frequency/high-risk tasks
* Humans **design** governance/control functions into the process and assets, then monitor, evaluate, improve, and supervise continuously 

The slide shows examples of what gets embedded:

* Reference-asset preparation
* Analysis support
* Test case generation + review
* Semi-automated release
* Automated testing
* “Data gatekeeper” functions 

---

### 4.5 Governance DX/AX and “new-type” talent

The deck argues governance must become agile at the same pace as development:

* shift from “human-based, reactive” governance
* to “data + digital tech (including AI), continuous, predictive, timely, agile governance” 

**Key success factor:** “new-type” engineers / business people who can:

* understand governance/control as business requirements
* **design and implement** them into development processes and architecture
  …and not treat governance as “just tool adoption.” 

---

### 4.6 Example: governance tooling in DevOps

A reference example shows a productized approach:

* a tool that automatically and continuously evaluates evidence for risk controls across DevOps environments
* and a “data-centric AI” version under development
* positioned across Biz↔Dev, Dev↔Ops, Ops↔Biz flows 

**Summary statement (from the deck):**

* Treat disruption/governance innovation as a chance for “new-type” evolution
* Governance by Design is essential
* Developing “new-type” talent is the biggest challenge/gap
* This transformation is also an opportunity to contribute to social issues and build new careers 

---

## 5. Panel Discussion

The session provides three panel prompts (via Slido):

1. **How to proceed with planning/development and how to change it** 
2. **Tips for getting used to tools and how to learn** 
3. **How humans will evolve — what comes after “new-type”** 

**How to interpret these prompts using the lectures:**

* Prompt 1 connects to *Hypervelocity Engineering*: restructure work into “Design → Issues → Deployable units,” with feedback loops and shared artifacts. 
* Prompt 2 connects to the *vibe coding ladder*: start from small wins (Level 1 → Level 2), then expand while keeping security/data constraints in mind.  
* Prompt 3 connects to governance + talent: “new-type” is the ability to translate business requirements (including governance) into engineered processes and systems. 

---

## 6. Q&A

A dedicated Q&A section is included in the session deck. 

**Good Q&A themes suggested by the materials:**

* “How do we decide what’s safe to vibe-code vs what needs full engineering?”
* “How do we embed governance checks into CI/CD without slowing down?”
* “What artifacts should Product/Business teams produce so engineering + AI can move fast?”
* “How do we standardize prompt development like we standardize code?”

(These map directly to the deck’s emphasis on structured upstream artifacts, prompt engineering, and governance-by-design pipelines.  )

---

## 7. Closing + What’s next

The deck includes a closing section and previews the next session themes:

* AI-enabled corporate finance & audit
* AI-era talent development and organizational management
* Summarizing “management in the AI era” across the course 

---

## Suggested exercises (optional)

1. **Pick one “pain” at work** → build a **Level-1** one-page tool (simple HTML/JS or visual) to remove friction. 
2. Convert it into **Level-2 automation** (Excel macro or small workflow automation). 
3. Add a “Trust, but verify” checklist (tests, validation rules, logging) aligned with governance-by-design thinking.  

---

If you tell me **which “parts” you mean** (e.g., *each slide*, *each chapter*, or *the 6 agenda sections*), I can restructure the `.md` to match exactly—but the content above follows the **official session parts (Opening → Lectures → Panel → Q&A → Closing)** shown in the deck. 
